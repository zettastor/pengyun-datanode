# -*- encoding=utf-8 -*-

#  Copyright (c) 2022. PengYunNetWork
#
#  This program is free software: you can use, redistribute, and/or modify it
#  under the terms of the GNU Affero General Public License, version 3 or later ("AGPL"),
#  as published by the Free Software Foundation.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
#   without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#   You should have received a copy of the GNU Affero General Public License along with
#   this program. If not, see <http://www.gnu.org/licenses/>.

# this is a code generator, generate config item location definition for perl and python
# for example, ssd.detect.by.speed config is in archive.properties, then this script will
# generate one entry, like (ssd.detect.by.speed, archive.properties), so when perl or python
# script try to read config ssd.detect.by.speed, they will only read it from archive.properties

import ConfigParser
import StringIO
import argparse
import os
import sys

parser = argparse.ArgumentParser(
    "code generator, generate config location definition for perl and python")
parser.add_argument("config_file_paths", metavar="config_file_path", nargs="+",
                    help="config file to parse, need file path")
parser.add_argument("--dry_run", action="store_true", default=False,
                    help="just parse config file, don't generate definition file, this can check whether there is "
                         "duplicate config item in different config file")

args = parser.parse_args()

script_folder = sys.path[0]
config_file_paths = args.config_file_paths
dry_run = args.dry_run

# open config to get config names
config_dict = {}
default_section = "root"
for file_path in config_file_paths:
  file_name = os.path.basename(file_path)
  config = ConfigParser.ConfigParser()
  with open(file_path, "r") as f:
    section_str = "[%s]\n" % default_section
    config.readfp(StringIO.StringIO(section_str + f.read()))
    for name, value in config.items(default_section):
      if name in config_dict:
        # find duplicate config stop and notify user to fix
        print(
            "find duplicate config:[{config_name}] in file:[{config_file1}] and file:[{config_file2}], "
            "this is big error, please fix it".format(config_name=name,
                                                      config_file1=config_dict[
                                                        name],
                                                      config_file2=file_name))
        exit(-1)
      else:
        config_dict[name] = file_name

config_tuples = sorted(config_dict.iteritems(), key=lambda t: (t[1], t[0]))

print("Find configs as below:")
for (name, value) in config_tuples:
  print("name:[%-50s] value:[%-30s]" % (name, value))

if dry_run:
  print(
      "just dry run, code generator finish running, didn't generate new code definition file, exit.")

print("")

comment_lines = [
  "# this source code is auto generated by script {script_name},".format(
      script_name=os.path.basename(__file__)),
  "# please don't modify it manuly!!! Just use the script to auto generate it.",
  "",
  ""
]

# generate definition file for perl
perl_contents = comment_lines \
                + [
                  "package ConfigLocation;",
                  "use strict;",
                  "use warnings FATAL => 'all';",
                  "",
                  "our %configLocation = (",
                ] \
                + ['    %-60s=> "%s",' % ('"' + config_name + '"', config_file)
                   for (config_name, config_file) in config_tuples] \
                + [
                  ");",
                  "",
                  "1;",
                ]

perl_file_path = os.path.join(script_folder, "ConfigLocation.pm")
# with open(perl_file_path, "w") as f:
#     f.writelines([line + "\n" for line in perl_contents])

print("Generate file:[{file_name}] for perl success.".format(
    file_name=os.path.basename(perl_file_path)))

# generate definition for python
python_contents = comment_lines \
                  + [

                    "# -*- encoding=utf-8 -*-",
                    "",
                    "config_location = {",
                  ] \
                  + ['    %-60s: "%s",' % ('"' + config_name + '"', config_file)
                     for (config_name, config_file) in config_tuples] \
                  + [

                    "}"
                  ]

python_file_path = os.path.join(script_folder, "config_location.py")
with open(python_file_path, "w") as f:
  f.writelines([line + "\n" for line in python_contents])

print("Generate file:[{file_name}] for python success.".format(
    file_name=os.path.basename(python_file_path)))

print("script execute finish.")
